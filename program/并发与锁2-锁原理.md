# 并发与锁序列（二）--锁的原理

​											-- 2020-01-15



## 基础概念

- 并发与并行的区别：

	​	单核CPU可以并发运行， 但是不能并行执行。
	​	并行是同一时刻多任务处理。并发是一个时间段内多任务处理。


- 线程安全问题

  ​	在并发编程中， 能够正确处理多个并发任务之间对共享变量、资源。



## 编译优化与线程安全

- 编译优化： 
  - 编译器优化：重排代码顺序，优先读操作（读有更好的性能，因为cache中有共享数据，而写操作，会让共享数据失效）
  - CPU优化：指令执行乱序（多核心协同处理，自动优化和重排指令顺序）
- 优化屏蔽：
  - 优化屏蔽：禁止编译器优化。按照代码逻辑顺序生成二进制代码，volatile关键词
  - 内存屏蔽：禁止CPU优化。防止指令之间的重排序，保证数据的可见性，store barrier, load barrier, full barrier
  - 写屏障：阻塞直到把Store Buffer中的数据刷到Cache中
  - 读屏障：阻塞直到Invalid Queue中的消息执行完毕
  - 全屏障：包括读写屏障，以保证各核的数据一致性

## 加锁的原理

- 禁止编译器做优化（加了优化屏蔽）
- 禁止CPU对指令重排（加了内存屏蔽）
- 针对缓存行、内存总线上的控制
- 冲突时的任务等待队列

## c++ 几种常见的锁

- 互斥锁（mutex）

  互斥锁用于控制多个线程对他们之间共享资源互斥访问的一个信号量。 在同一个时刻， 只有一个线程可以获取互斥锁。

- 条件锁（condition_variable 需要和std::mutex 一起工作）

  条件锁就是所谓的条件变量，某一个线程因为某个条件为满足时可以使用条件变量使改程序处于阻塞状态。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。

- 自旋锁

  互斥锁是是一种sleep-waiting的锁。而自旋锁是一种busy-waiting的锁。从“自旋锁”的名字也可以看出来，如果一个线程想要获取一个被使用的自旋锁，那么它会一致占用CPU请求这个自旋锁使得CPU不能去做其他的事情，直到获取这个锁为止，这就是“自旋”的含义。

- 读写锁

  你可以使用boost::shared_ mutex的实例来实现同步，而不是使用std::mutex的实例。对于更新操作，std::lock_guard< boost::shared _mutex>和 std::unique _lock< boost::shared _mutex>可用于锁定，以取代相应的std::mutex特化。这确保了独占访问，就像std::mutex那样。那些不需要更新数据结构的线程能够转而使用 boost::shared _lock< boost::shared _mutex>来获得共享访问。这与std::unique _lock用起来正是相同的，



## 参考文献

- <http://km.oa.com/group/34294/articles/show/366165?kmref=search&from_page=1&no=2>

- <https://www.jianshu.com/p/17be890865e7>

- <https://blog.csdn.net/qq_35642036/article/details/82801708>